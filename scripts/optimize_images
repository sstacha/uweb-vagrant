#!/bin/bash
# script to optimize images

# Initialize our constants:
MAKE_CHANGES=true
# todo: change to true when we want to convert everything to webp versions of the files
# NOTE: The idea is that the webserver will serve up webp to those that support it instead of the regular file
ENABLE_WEBP=false
IGNORE_FILES=".DS_Store .git"
IGNORE_DIRECTORIES="/home/ubuntu/server/website/docroot/images/fixed-images /tmp/test-noprocess"
IMAGE_MAX_WIDTH=1024
IMAGE_FILE_EXTENSIONS="*.jpg *.jpeg *.png *.tiff *.gif"
# todo: uncomment when we are ready to do different sizes
# IMAGE_FILE_WIDTH_SIZES="300 600 1080"
IMAGE_FILE_WIDTH_SIZES=""

# Initialize our variables:
# default source and target dirs; change this for your environment
_image_source='/home/ubuntu/server/website/docroot/files'
_image_target='/home/ubuntu/server/website/images'
#_image_source='/vagrant/test_images'
#_image_target='/vagrant/test_optimized'
# option choices
_all=false
_remove_cache=false
_convert=false
_optimize=false
_diff=false
_log_verbose=false
# absolute versions of the source and target parameters
_full_source=""
_full_target=""

debug () {
		if [ "$_log_verbose" = "true" ] ; then
        	echo $1;
        fi
}

show_help() {
    echo "usage: ./uweb_images.sh [-h][-a][-v][-c][-o][-f][-d][-s][-t]"
    echo "     -h or ?: show usage help"
    echo "     -v: show verbose logging"
    echo "     -r: remove cached image"
    echo "     -a: all - runs both convert and optimize on all images (if dir) or image (if file)"
    echo "     -c: only convert and crop any >1028 width"
    echo "     -o: only optimize with compression (uses image_optim)"
    echo "     -d: recursively runs conversion and optimizations on only files different between the directories instead of all files in all directories"
    echo "     -t: use the path given as an override for the target directory where optimized images are stored"
    echo " argument: use the path or file given as an override for the source file or directory"
}

strip_slash() {
    echo "$1"|sed 's/\/$//g'
}
trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}
# determine if the path is relative and if so adds the pwd or passed parameter; we need to do operations on absolute files
get_absolute_file() {
    _gaf_curdir=$(pwd)
    _opt_file="$1"
    # echo "gaf curdir: $_gaf_curdir"
    # if the source file or directory doesn't start with a slash then append the cwd
    if [[ ${_opt_file:0:1} == "/" ]] ;then
        echo $_opt_file
    else
        echo "$_gaf_curdir/$_opt_file"
    fi
}
get_abs_path() {
    _gap_basedir="$(strip_slash $1)"
    echo "gap base dir: "$_gap_basedir
    _gap_provided_param="$2"
    echo "gap provided param: "$_gap_provided_param
    # if the source file or directory doesn't start with a slash then append the cwd
    if [[ ${_gap_provided_param:0:1} == "/" ]] ;then
        echo "gap param started with / so returning public path"
        echo $_gap_provided_param
    else
        echo "gap param didn't start with / so append theem together"
        echo "$_gap_basedir/$_gap_provided_param"
    fi
}
# will call mogrify wrapper for each condition we have for each directory
mogrify_directory() {
    md_directory=$1
    md_target_dir=$_full_target

    if [[ "$md_directory" == "$md_target_dir" ]]; then
        sr_target_dir=""
    fi

    md_directory=$(strip_slash $md_directory)
    # when we are asked to mogrify a directory we will do so for each type we support
    for md_ext in $IMAGE_FILE_EXTENSIONS; do
        # first call mogrify for each extension without resizing as the default
        debug "[mogrify_directory] calling mogrify wrapper $md_directory/$md_ext $md_target_dir"
        mogrify_wrapper "$md_directory/$md_ext" $md_target_dir $md_size $p_ext
        if [[ "$ENABLE_WEBP" == "true" ]]; then
            # do the same thing for webp
            mogrify_wrapper "$md_directory/$md_ext" $md_target_dir "" "webp $p_ext"
        fi
        for md_size in $IMAGE_FILE_WIDTH_SIZES; do
            md_pattern="$md_directory/$md_ext"
            p_ext="${md_ext##*.}"
            p_ext="$md_size.$p_ext"
            # then call mogrify for each file size we want in our src selections
            debug "[mogrify_directory] calling mogrify wrapper $md_pattern $md_target_dir $md_size $p_ext"
            mogrify_wrapper $md_pattern $md_target_dir $md_size $p_ext
            if [[ "$ENABLE_WEBP" == "true" ]]; then
                # do the same thing for webp
                mogrify_wrapper $md_pattern $md_target_dir $md_size "webp $p_ext"
            fi
        done
    done

}
# will call mogrify for each condition for each file passed
# this is pretty similar to directory except our pattern is passed through
mogrify_file() {
    mf_file=$1
    mf_target_dir=$_full_target
    mf_ext="${mf_file##*.}"
    # when we are asked to mogrify a file we will use it's extension and bail if we don't have one
    if [[ "$mf_ext" == "" ]]; then
        echo "We requested to process a file that did not have an extension; skipping since we wouldn't know what format to use"
    else
        # first call mogrify for each extension without resizing as the default
        debug "[mogrify_file] calling mogrify wrapper $mf_file $mf_target_dir"
        mogrify_wrapper $mf_file $mf_target_dir
        if [[ "$ENABLE_WEBP" == "true" ]]; then
            # try converting everything to webp also
            p_ext="webp $mf_ext"
            mogrify_wrapper $mf_file $mf_target_dir "" $p_ext
        fi
        for mf_size in $IMAGE_FILE_WIDTH_SIZES; do
            p_ext="$mf_size.$mf_ext"
            # then call mogrify for each file size we want in our src selections
            debug "[mogrify_directory] calling mogrify wrapper $mf_file $mf_target_dir $mf_size $p_ext"
            mogrify_wrapper $mf_file $mf_target_dir $mf_size $p_ext
            if [[ "$ENABLE_WEBP" == "true" ]]; then
                # try converting everything to webp
                # todo: see if this keeps our .600.webp extension or renames to just .webp
                p_ext="webp $p_ext"
                mogrify_wrapper $mf_file $mf_target_dir $mf_size $p_ext
            fi
        done
    fi
}
mogrify_wrapper() {
    debug "[mogrify_wrapper] in mogrify_wrapper()"
    mw_source_pattern=$1
    mw_target_dir=$2
    mw_target_size=$3
    mw_target_ext=$4

    # we must have a source pattern or error
    if [[ "$mw_source_pattern" == "" ]]; then
        echo "Attempted to call mogrify but nothing was passed for the source file to work against; aborting.  This shouldn't happen."
        exit 1
    fi
    if [[ "$mw_target_dir" == "" ]]; then
        debug "[mogrify_wrapper] target directory was not passed; omitting from the mogrify call"
    else
        mw_target_dir="-path $mw_target_dir"
    fi
    if [[ "$mw_target_size" == "" ]]; then
        debug "[mogrify_wrapper] target size was not passed; defaulting to less than IMAGE_MAX_WIDTH"
        p_target_size="-resize 1024>"
    else
        p_target_size="-resize $mw_target_size"
    fi
    if [[ "$mw_target_ext" == "" ]]; then
        debug "[mogrify_wrapper] target extension was not passed; omitting from the mogrify call"
    else
        mw_target_ext="-format $mw_target_ext"
    fi

    debug "[mogrify_wrapper] mw_source_pattern: $mw_source_pattern"
    debug "[mogrify_wrapper] mw_target_dir: $mw_target_dir"
    debug "[mogrify_wrapper] mw_target_size: $mw_target_size"
    debug "[mogrify_wrapper] p_target_size: $p_target_size"
    debug "[mogrify_wrapper] mw_target_ext: $mw_target_ext"
    debug "[mogrify_wrapper] calling \"mogrify $mw_target_dir $mw_target_ext $p_target_size -filter Triangle -define filter:support=2 -thumbnail 100% -unsharp 0.25x0.08+8.3+0.045 -dither None -posterize 136 -quality 82 -define jpeg:fancy-upsampling=off -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 -define png:exclude-chunk=all -interlace none -colorspace sRGB $mw_source_pattern\""


    # make our mogrify call with the options we have
    if [[ "$MAKE_CHANGES" == "true" ]]; then
        mogrify $mw_target_dir $mw_target_ext $p_target_size -filter Triangle -define filter:support=2 -thumbnail 100% -unsharp 0.25x0.08+8.3+0.045 -dither None -posterize 136 -quality 82 -define jpeg:fancy-upsampling=off -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 -define png:exclude-chunk=all -interlace none -colorspace sRGB $mw_source_pattern
    fi
}
# main method to do the resize and scaling optimizations
smartresize() {
    debug '[smartresize] $1: '$1
    sr_source="$1"
    sr_target_dir="$_full_target"

    # when we call smartresize we pass a source pattern; this could be a file or directory or it could be a glob pattern like ne*
    # we will separate the absolute path from the pattern and run a find to get either a single file or directory or a set of files and directories
    # at this point we should always have an absolute path with either a file, folder, or pattern
    # if it contains a file we want to run mogrify on it for each size
    if [[ -f "$sr_source" ]]; then
        debug "[smartresize] determined source passed was a file; calling file mogrify..."
        mogrify_file $sr_source
    elif [[ -d "$sr_source" ]]; then
        debug "[smartresize] determined source passed was a directory; calling directory mogrify for each directory recursively..."
        # stripping the last slash if it is there so I don't get double slashes after apending the *
        sr_folder=$(strip_slash "$sr_source")
        # first call for our directory then all children
        debug "[smartresize] calling directory mogrify $sr_source"
        mogrify_directory $sr_source
        for d in $(find $sr_folder/* -type d); do
            debug "[smartresize] calling directory mogrify $d"
            mogrify_directory $d
        done
    else
        # we have a pattern so lets issue a find with the pattern and then for each file call mogrify
        for f in $(find $sr_source -type f | grep -E '.gif$|.jpg$|.jpeg$|.png$|.tiff$'); do
            debug "[smartresize] calling file mogrify $f"
            mogrify_file $f
        done
    fi
}



# parse all options using getargs...
# A POSIX variable
OPTIND=1         # Reset in case getopts has been used previously in the shell.

while getopts "h?vacodt:r" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  _log_verbose=true
        ;;
    r)  _remove_cache=true
        ;;
    a)  _all=true
        ;;
    c)  _convert=true
        ;;
    o)  _optimize=true
        ;;
    d)  _diff=true
        ;;
    t)  _image_target=$OPTARG
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

if [ ! -z $@ ]; then
	_image_source=$@
fi

_full_source=$(get_absolute_file $_image_source)
_full_target=$(get_absolute_file $_image_target)
_optarg=$@

# if no action option is passed and no argument then assume all
if [[ "$_convert" == "false" && "$_optimize" == "false" && "$_all" == "false" && "$_remove_cache" == "false" && "$_diff" == "false" ]]; then
    _diff=true
fi

debug "options: "
debug "all:$_all"
debug "remove cache:$_remove_cache"
debug "convert:$_convert"
debug "optimize:$_optimize"
debug "diff:$_diff"
debug "verbose logging:$_log_verbose"
debug "argument: $@"
debug "_image_source:$_image_source"
debug "_image_target:$_image_target"
debug "full source: $_full_source"
debug "full_target: $_full_target"
debug "MAKE_CHANGES: $MAKE_CHANGES"
debug "IGNORE_FILES: $IGNORE_FILES"
debug "IMAGE_MAX_WIDTH: $IMAGE_MAX_WIDTH"
debug "IMAGE_DEFAULT_WIDTH: $IMAGE_DEFAULT_WIDTH"
debug ""

# ----- validation rules before we start executing with options ------
# make sure the _image_source and _image_target exist and are directories; do not error if the output doesn't exist prompt and create
# check that we have appropriate directories or bail
if [[ "$_remove_cache"  != "true" ]]; then
    if [[ -d "$_full_source" || -f "$_full_source" ]]; then
        debug "validation: [$_full_source] exists; continuing..."
    else
        echo "You have requested to optimize images passing the file or directory [$_image_source].  The file or directory does not exist so there will be nothing to optimize.  Please set the default script variable correctly or use the option: -s <source file or dir>"
        exit 1
    fi
fi
if [ -f "$_full_target" ]; then
    echo "The target directory exists as a file.  This is not allowed.  You must pass a directory to put the resulting optimized image(s) in.  Please remove the file or use the option: -t <target dir>"
    exit 1
elif [ -d "$_full_target" ]; then
    debug "validation: [$_full_target] exists and is a directory; continuing..."
else
    echo "The target directory to store the optimized images [$_full_target] does not exist.  This could be becuase it is incorrect or becuse it doesn't exist yet. If it is incorrect, re-run and use the option: -t <target dir>"
    echo 'Do you to create the target directory for the optimized images and proceed? [y/N]'
    read _user_answer
    debug "user answer: [$_user_answer]"
    echo ""
    if [[ "$_user_answer" != "y" && "$_user_answer" != "Y" ]]; then
        echo " "
        echo "done"
        exit 0
    fi
    if [[ "$MAKE_CHANGES" == "true" ]]; then
        # they said yes so create the directory if we can
        mkdir -p $_full_target
    fi
fi
# we do allow files for the source but if we do a diff then we need a directory since otherwise a diff does not make sense
if [[ "$_diff" = "true" && ! -d "$_full_source" ]]; then
    echo "You have asked to run conversions and optimizations on files that differ between the source and target directories, however, [$_full_source] is not a directory.  Please ensure you use a source directory when using the diff option."
    exit 1
fi
# if we don't have an image source given or defaulted bail!
if [ -z $_image_source ]; then
	echo "You have requested to optimize images without giving a source or a defaulted source in the script.  There is nothing to do.  Add a default source or pass something as a parameter."
	exit 0
fi


echo ' '
# ----- validation rules before we start executing with options ------

# if we get a diff option remove all files removed from source and call smartresize and optimize on all files added to source
if [ "$_diff" = "true" ]; then
    debug '[diff] deleting all images not in the source directory but exist in the target directory...'
    # diff might get a bit tricky we need to do string parsing to get our list and call remove for each file found
    delfiles=$(diff -r $_full_source $_full_target | grep $_full_target | grep '^Only' | grep -E '.gif$|.jpg$|.jpeg$|.png$|.tiff$' | awk '{print $3$4}')
    echo "removing all files only in the target image directory [$_full_target]: "
    for df in $delfiles; do
        dtrim=${df%:*}  # retain the part before the colon
        ftrim=${df##*:} # retain the part after the last colon
        if [[ "$MAKE_CHANGES" == "true" ]]; then
            debug "[diff]     deleting [$dtrim/$ftrim]"
            rm $dtrim/$ftrim
        fi
        echo "     deleted [$dtrim/$ftrim]"
    done
	debug '[diff] running conversion and optimization on all images not in the target directory...'
	# diff might get a bit tricky we need to do string parsing to get our list and call smartresize for each file found
    newfiles=$(diff -r $_full_source $_full_target | grep $_full_source | grep '^Only' | grep -E '.gif$|.jpg$|.jpeg$|.png$|.tiff$' | awk '{print $3$4}')
    echo "converting and optimizing all files only in the source directory [$_full_source]: "
    for nf in $newfiles; do
        debug "[diff] optimizing [$nf]"
        # we need to trim our directory before sending since diff has <directory>:<filename with extension> and we need to get rid of the colon and add a /
        dtrim=${nf%:*}  # retain the part before the colon
        ftrim=${nf##*:} # retain the part after the last colon
        debug "[diff] dtrim: $dtrim"
        debug "[diff] ftrim: $ftrim"
        debug "[diff] calling smartresize $dtrim/$ftrim"
        if [[ "$MAKE_CHANGES" == "true" ]]; then
            smartresize "$dtrim/$ftrim"
            image_optim -r --no-pngout $_full_target/$ftrim
        fi
        echo "     optimized [$dtrim/$ftrim]"
    done
    echo "done"
    exit 0
fi
# do a check for removal first
if [[ "$_remove_cache" == "true" ]]; then
    debug "[remove cache] removing requested directory or file pattern [$_optarg]!"
    _ostuff="$_optarg"
    if [[ "$_ostuff" == "" ]]; then
        _ostuff='*'
    fi
    if [[ "$MAKE_CHANGES" == "true" ]]; then
        if [[ "$_full_target" != "" ]]; then
            rm -rf $_full_target/$_ostuff
        fi
    fi
    echo "executed rm for [$_full_target/$_ostuff]"

	# remove_cache
fi
# if we get the all option just delete everything and set the convert and optimize options which should call smartresize for the source folder
if [ "$_all" = "true" ]; then
    debug "[all] removing target directory contents [$_full_target]!"
	if [[ "$MAKE_CHANGES" == "true" ]]; then
        if [[ "$_full_target" != "" ]]; then
            rm -rf $_full_target/*
        fi
    fi
    echo "[$_full_target] deleted.  recreating..."
    _convert="true"
    _optimize="true"
	debug '[all] running conversion and optimization on the image directory...'
fi
if [ "$_convert" = "true" ]; then

	# call smartresize with our source parameter
	echo "[convert] converting [$_full_source]"
	smartresize $_full_source
    debug "[convert] done converting"
    if [ "$_optimize" != "true" ]; then
        exit 0
    fi
fi

debug '$_optimize: '$_optimize
if [ "$_optimize" = "true" ]; then
    if [[ "$MAKE_CHANGES" == "true" ]]; then
        image_optim -r --no-pngout $_full_target
    fi
    echo "done optimizing"
    exit 0
fi
