#!/bin/bash
# script to back up and archive files NOTE: ideally would call svn or git commit to keep in version control
# example1: archive httpd.conf -> will archive httpd.conf with current directory to archive directory preserving directory structure
# example2: archive -c httpd.conf -> will replace the current archive file in the current dir location with the existing file preserving directory structure
# the idea being you can re-create a server and then lay down the current files to replace configurations easily

CURDIR=$(pwd)
ARCHIVE_DIR=/home/ubuntu/server/archive/dated
CURRENT_DIR=/home/ubuntu/server/archive/current

yell() { echo "$0: $*" >&2; }
die() { yell "$*"; exit 111; }
try() { "$@" || die "cannot $*"; }

# Initialize our own variables:
_opt_verbose=false
_opt_current=false
_opt_restore=false
_opt_sync=false
_full_file=""
_full_archive=""

log () {
		if [ "$_opt_verbose" = "true" ] ; then
        	# log all messages
        	echo $1;
        fi
}

show_help() {
    echo "usage: archive [-h?][-v][-c][-r]" 
    echo "     -h/?: show usage help"
    echo "     -v: show verbose logging"
    echo "     -c: archive to current folder as well as dated folder"
    echo "     -r: make dated backup of all files in current archive then restore to external locations"
    echo "     -s: sync all current files with the current location contents if they differ"
    echo "          NOTE: primarily thinking it will be used by cron to keep the archive current folder up to date on a server if someone forgets to archive current changes"
    echo "          NOTE: this may not be what we want since it will "always" make sure the current file is current"
    echo "          TODO: implement when needed"
    echo " no option: only archive file or directory items to the dated folder"
}

get_absolute_file() {
    # echo "gaf _full_file: $_full_file"
    # echo "gaf _opt_file: $_opt_file"
    # get the current directory for use
    _gaf_curdir=$(pwd)    
    # if a parameter is passed use it instead
    # echo "get_absolute_file arg1: $1"
    if [[ "$1" != "" ]]; then
        _gaf_prefix=$1
    fi
    # echo "gaf prefix: $_gaf_prefix"
    # echo "gaf curdir: $_gaf_curdir"
    # echo "gaf optfile: $_opt_file"
    # if the option passed doesn't start with a slash then append the cwd
    if [[ ${_opt_file:0:1} == "/" ]] ;then 
        echo $_opt_file 
    else
        if [[ "$_gaf_prefix" != "" ]]; then
            echo "$_gaf_prefix$_gaf_curdir/$_opt_file"
        else
            echo "$_gaf_curdir/$_opt_file"
        fi
    fi
}

save() {
    # if directory we need to do a loop otherwise we just do one file
    if [[ -d "$_full_file" ]]; then
        # write code to loop and save each one
        log "looping and saving each file in dir [$_full_file]"
    else
        # copy the file requested to the archive location keeping the directory structure
        try mkdir -p $ARCHIVE_DIR$CURDIR
        dtf=`date +%Y%m%d%H%M%S`
        try cp -a $_opt_file $ARCHIVE_DIR$CURDIR/$_opt_file.$dtf
        echo archived $ouput_file to $ARCHIVE_DIR$CURDIR/$_opt_file.$dtf
    fi

}
save_current() {
    # if directory we need to do a loop otherwise we just do one file
    if [[ -d "$_full_file" ]]; then
        # write code to loop and save each one
        log "saving each file in [ $_full_file ]"
    else
        log "saving [ $_full_file ]"
    fi

}

# parse all options suing getargs...
# A POSIX variable
OPTIND=1         # Reset in case getopts has been used previously in the shell.

while getopts "h?vcf:rs" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  _opt_verbose=true
        ;;
    c)  _opt_current=true
        ;;
    r)  _opt_restore=true
        ;;
    s)  _opt_sync=true
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

_opt_file=$@
log "options: \nverbose:$_opt_verbose,\n current:$_opt_current restore:'$_opt_restore', Leftovers: $_opt_file"
if [[ "$_opt_file" == "." ]]; then
    _opt_file=""
fi
_full_file=$(get_absolute_file)
_full_archive=$(get_absolute_file $ARCHIVE_CURRENT)

echo "opt file: $_opt_file"
echo "full file: $_full_file"
echo "full archive: $_full_archive"

dirs_exist=0
# check that we have appropriate directories or bail
if [ -f "$ARCHIVE_DIR" ]; then
	if [ -f "$CURRENT_DIR" ]; then
		dirs_exist = 1
	fi
fi
if [ $dirs_exist ]; then
	log 'archive and current directories exist; continuing...'
else
	echo 'ERROR: archive and current directory does not exist'
	echo "run: sudo mkdir -p $ARCHIVE_DIR"
	echo "run: sudo mkdir -p $CURRENT_DIR"
	echo "run: sudo chown -R ubuntu:_developer $ARCHIVE_DIR"
	echo "run: sudo chown -R ubuntu:_developer $CURRENT_DIR"
	echo "run: sudo chmod -R 775 $ARCHIVE_DIR"
	echo "run: sudo chmod -R 775 $CURRENT_DIR"
	echo " then try archiving your file again"
	exit 1
fi		

# validate that we have a parameter passed for the file/directory if we are not doing a sync or restore
if [[ "$_opt_restore" = "false" && "$_opt_sync" = "false" ]]; then
    echo "not r or s so make sure we have a valid directory and set the variable for use later"
        
    if [[ -f "$_full_file" || -d "$_full_file" ]]; then
        log "file or directory found @ $_full_file"
        if [[ -d "$_full_file" ]]; then
            # ask if they want to really do this
            echo "You have requested to back up all files in directory [$_full_file]"
            echo 'Are you sure? [y/N]'
            read _user_answer
            echo "user answer: [$_user_answer]"
            
            if [[ "$_user_answer" != "y" && "$_user_answer" != "Y" ]]; then
                echo "Bailing then, excute again passing the file name you want to archive."
                exit 0
            fi
        fi
     else
        echo "unable to locate file or directory @ $_full_file"
        exit 1
    fi
fi

echo "full file: $_full_file"

# validate that there are not combinations of options that do not make sense
# it does not make sense to allow archiving current and restoring current at the same time.  r should not be used
#   with c or s
if [[ ("$_opt_current" = "true" && "$_opt_restore" = "true") || ("$_opt_sync" = "true" && "$_opt_restore" = "true") ]]; then
    echo "You have requested to both archive current files and restore current files at the same time.  This does not make sense and is probably an error.  If this was truly your intention please enter each command separately."
    exit 1
fi
# it does not make sense to sync and archive current at the same time; sync requires file from current_achive and current 
#   requires external file outside the archive directory
if [[ "$_opt_current" = "true" && "$_opt_sync" = "true" ]]; then
    echo "You have requested to sync all current files and sync a current file or directory.  This does not make sense since the first case uses the archive directory to specify which files and the second uses an external directory.  Retry with one or the other."
    exit 1
fi



# if we are restoring we need to make sure we are in the archive directory path and the file exists in the current or dated directories
if [ "$_opt_restore" = "true" ]; then
    echo "opt_restore is true; checking for archive dir -> external location"
    # first check that they didn't leave the file argument blank.  if they did restore everything
    if [[ "$_opt_file" = "" ]]; then
        echo "Backing up and restoring all current files to their repective directories..."
        # loop through each current folder files and make a dated backup of each one to get back to
        # NOTE: backup may not exist; check first
        
        # restore each file to its directory preserving permissions
        
    else
        # normally _full_file variable is appended pwd but for archive lets try to take the file opt and append the archive current directory instead
        
        echo "_full_archive: $_full_archive"
        if [[ "$(echo $_full_file | grep $ARCHIVE_DIR)" == "" ]]; then
            echo "You have requested to restore a file outside the archive directory.  This is not possible.  To restore a file use"
            echo "\$ARCHIVE_CURRENT/<path to file> or \$ARCHIVE_DATED/<path to file>.<datetimestamp>"
            echo "NOTE: This path should match a file in your respective archive directory location."
            echo "NOTE: To restore everything execute: archive -r"
            exit 1
        else
            # backup and restore the file they requested
            # NOTE: backup may not exist; check first
            echo "backed up $_full_archive"
        fi
    fi
else
    echo "something other than restore so assume external location -> archive dir"
    # if we are archiving or archiving current do not allow files in the archive directory.  while this might be legitimate in very rare case it is almost always an error.  Let them do copys manually instead
    if [[ "$(echo $_full_path | grep $ARCHIVE_DIR)" != "" ]]; then
        echo "You have requested to archive a file in the archive directory.  This is not allowed as it can cause problems.  If you want to copy things in the archive directory please copy them manually."
        exit 1
    fi
    # we always want to do a dated backup
    echo "archiving..."
    echo "from: $_full_file"
    echo "to: $_full_archive"
    # if current we want to do a current overrite
    
    
    
fi

exit 0

# end of variable parsing and validation checks


log '$_opt_current: '$_opt_current
if [ "$_opt_current" = "true" ]; then
	log 'setting current files...'
	try mkdir -p $CURRENT_DIR$CURDIR		
	cp -a $_opt_file $CURRENT_DIR$CURDIR/$_opt_file
	echo archived $_opt_file to $CURRENT_DIR$CURDIR/$_opt_file
    To restore all current files: sudo cp -pR $ARCHIVE_CURRENT/* /
    To restore a single file replace * and the destination with the path and filename for the file
fi

# try to cleanup lots of files...
cnt=$(ls $ARCHIVE_DIR$CURDIR/$_opt_file.* | wc -l)
if [ $cnt -lt 11 ]; then
	echo $cnt' archived versions of this file found; not enough to cleanup...'
else
	echo $cnt' archived versions of this file found; cleaning up old files...'
	ls -t $ARCHIVE_DIR$CURDIR/$_opt_file.* | tail -n +11 | xargs rm -f --
fi
echo 'done'